<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DinoPepe ü¶ñ</title>

<link rel="manifest" href="manifest.json">

<meta name="theme-color" content="#4caf50">

<link rel="apple-touch-icon" href="icon-192.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="DinoPepe">

<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    background: #87ceeb;
    font-family: 'Courier New', monospace;
    overflow: hidden;
    text-align: center;
    touch-action: none;
    transition: background 2s ease;
}

canvas {
    display: block;
    margin: 0 auto;
    cursor: pointer;
}

#ui {
    position: fixed;
    top: 8px;
    width: 100%;
    z-index: 10;
    font-size: 13px;
    color: #333;
    text-shadow: 1px 1px 2px white;
}

#pauseBtn {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 3rem;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: none;
    background: rgba(76, 175, 80, 0.9);
    color: white;
    cursor: pointer;
    z-index: 100;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    display: none;
}

#pauseBtn:active {
    transform: translate(-50%, -50%) scale(0.95);
}

#powerupBar {
    margin-top: 6px;
    font-size: 12px;
}

.active-powerup {
    background: rgba(76, 175, 80, 0.3);
    padding: 2px 8px;
    border-radius: 4px;
    display: inline-block;
    margin: 0 4px;
}

#upload {
    margin-top: 8px;
}

#upload input {
    font-size: 12px;
    padding: 4px 8px;
}

#photoPreview {
    display: none;
    margin-top: 8px;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

#photoPreview img {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid #4caf50;
}

#removePhoto {
    padding: 4px 8px;
    background: #f44336;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 11px;
}

#gameOverScreen, #tutorialScreen {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.85);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    z-index: 999;
}

#tutorialScreen {
    display: flex;
}

#tutorialScreen h2 {
    margin-bottom: 20px;
    font-size: 2rem;
}

#tutorialScreen p {
    font-size: 1.2rem;
    margin: 10px 0;
}

.btn {
    font-size: 1.5rem;
    padding: 12px 32px;
    margin: 10px;
    border-radius: 12px;
    border: none;
    background: #4caf50;
    color: white;
    cursor: pointer;
    transition: transform 0.1s;
}

.btn:active {
    transform: scale(0.95);
}

#gameOverScreen h1 {
    font-size: 2.5rem;
    margin-bottom: 20px;
}

#finalScore {
    font-size: 1.8rem;
    margin: 10px 0;
}
</style>
</head>

<body>

<div id="tutorialScreen">
    <div>
        <h2>ü¶ñ DinoPepe</h2>
        <p>üéÆ Como jogar:</p>
        <p>üì± <strong>Celular:</strong> Balance para cima ou toque na tela</p>
        <p>üíª <strong>PC:</strong> Pressione ESPA√áO ou clique</p>
        <p>ü™ô Colete moedas e power-ups!</p>
        <p>üõ°Ô∏è Escudo | üß≤ √çm√£ | ‚è±Ô∏è Slow-mo</p>
        <p><br>Envie uma foto para usar como rosto do dino!</p>
        <button class="btn" id="startBtn">Come√ßar</button>
    </div>
</div>

<div id="ui">
    <div style="font-size: 16px; font-weight: bold;">ü¶ñ DinoPepe</div>
    <div id="scoreText"></div>
    <div id="powerupBar"></div>
    <div id="upload">
        <input type="file" id="faceUpload" accept="image/*">
        <div id="photoPreview">
            <img id="previewImg" src="" alt="Preview">
            <button id="removePhoto">Remover</button>
        </div>
    </div>
</div>

<canvas id="game"></canvas>

<button id="pauseBtn">‚è∏Ô∏è</button>

<div id="gameOverScreen">
    <h1>Game Over! üò¢</h1>
    <div id="finalScore"></div>
    <button class="btn" id="restartBtn">Jogar Novamente</button>
</div>

<script>
/* ================= CONFIG ================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = Math.min(400, window.innerHeight * 0.6);
}
resize();
window.addEventListener("resize", resize);

const GRAVITY = 0.65;
const JUMP_FORCE = -13.5;
const MAX_PARTICLES = 50;
const MAX_COINS = 30;
const MAX_POWERUPS = 5;
let gameSpeed = 5;
let baseGameSpeed = 5;
let gameStarted = false;
let gamePaused = false;

/* ================= SONS ================= */
function createBeep(freq, duration, type = 'sine') {
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    return () => {
        try {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            oscillator.frequency.value = freq;
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        } catch(e) {}
    };
}

const jumpSound = createBeep(800, 0.1, 'square');
const hitSound = createBeep(200, 0.3, 'sawtooth');
const coinSound = createBeep(1200, 0.05, 'sine');
const powerupSound = createBeep(1500, 0.15, 'triangle');

/* ================= TEMAS DIN√ÇMICOS ================= */
function getCurrentTheme(score) {
    if (score < 500) {
        return {
            skyTop: '#87ceeb',
            skyBottom: '#b8e6f5',
            groundColor: '#9be27d',
            cloudOpacity: 0.7,
            stars: false,
            moon: false,
            mountainColor: 'rgba(100, 140, 80, 0.4)'
        };
    } else if (score < 1500) {
        return {
            skyTop: '#ff9a56',
            skyBottom: '#ffd89b',
            groundColor: '#8ab85f',
            cloudOpacity: 0.5,
            stars: false,
            moon: false,
            mountainColor: 'rgba(120, 100, 70, 0.4)'
        };
    } else if (score < 3000) {
        return {
            skyTop: '#5f3b7a',
            skyBottom: '#c76ca6',
            groundColor: '#6b9151',
            cloudOpacity: 0.3,
            stars: true,
            moon: false,
            mountainColor: 'rgba(80, 60, 100, 0.5)'
        };
    } else {
        return {
            skyTop: '#1a1a2e',
            skyBottom: '#16213e',
            groundColor: '#4a6741',
            cloudOpacity: 0.2,
            stars: true,
            moon: true,
            mountainColor: 'rgba(40, 40, 60, 0.6)'
        };
    }
}

let currentTheme = getCurrentTheme(0);
let stars = [];

/* ================= POWER-UPS ================= */
let activePowerups = {
    shield: 0,
    magnet: 0,
    slowmo: 0
};

let powerups = [];
let powerupTimer = 0;

function createPowerup() {
    if (powerups.length >= MAX_POWERUPS) return;
    
    const types = ['shield', 'magnet', 'slowmo'];
    const type = types[Math.floor(Math.random() * types.length)];
    
    powerups.push({
        x: canvas.width + 30,
        y: groundY - 80 - Math.random() * 60,
        w: 30,
        h: 30,
        type: type,
        float: 0
    });
}

function updatePowerups() {
    if (!gameStarted || gamePaused) return;
    
    powerupTimer++;
    if (powerupTimer > 600 && Math.random() < 0.01) {
        createPowerup();
        powerupTimer = 0;
    }
    
    powerups.forEach(p => {
        p.x -= gameSpeed;
        p.float += 0.1;
        
        if (activePowerups.magnet > 0) {
            const dx = dino.x - p.x;
            const dy = dino.y - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 150) {
                p.x += dx * 0.08;
                p.y += dy * 0.08;
            }
        }
        
        if (
            dino.x < p.x + p.w &&
            dino.x + dino.w > p.x &&
            dino.y < p.y + p.h &&
            dino.y + dino.h > p.y
        ) {
            activePowerups[p.type] = 300;
            powerupSound();
            createParticles(p.x + p.w/2, p.y + p.h/2, '#ffd700');
            p.collected = true;
        }
    });
    
    powerups = powerups.filter(p => !p.collected && p.x + p.w > 0);
    
    Object.keys(activePowerups).forEach(key => {
        if (activePowerups[key] > 0) activePowerups[key]--;
    });
    
    if (activePowerups.slowmo > 0) {
        gameSpeed = baseGameSpeed * 0.5;
    } else {
        gameSpeed = baseGameSpeed;
    }
}

function drawPowerups() {
    powerups.forEach(p => {
        const y = p.y + Math.sin(p.float) * 5;
        
        ctx.save();
        ctx.shadowBlur = 15;
        ctx.shadowColor = 'rgba(255, 215, 0, 0.6)';
        
        if (p.type === 'shield') {
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(p.x + p.w/2, y + p.h/2, 12, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = '#64B5F6';
            ctx.font = '20px Arial';
            ctx.fillText('üõ°Ô∏è', p.x + 5, y + 22);
        } else if (p.type === 'magnet') {
            ctx.fillStyle = '#E91E63';
            ctx.fillRect(p.x + 5, y + 5, 8, 20);
            ctx.fillRect(p.x + 17, y + 5, 8, 20);
            ctx.fillStyle = '#C2185B';
            ctx.fillRect(p.x + 5, y + 20, 20, 5);
        } else if (p.type === 'slowmo') {
            ctx.strokeStyle = '#FF9800';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(p.x + p.w/2, y + p.h/2, 12, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = '#FFA726';
            ctx.beginPath();
            ctx.moveTo(p.x + 15, y + 15);
            ctx.lineTo(p.x + 15, y + 8);
            ctx.lineTo(p.x + 20, y + 15);
            ctx.fill();
        }
        
        ctx.restore();
    });
}

function drawPowerupBar() {
    let html = '';
    if (activePowerups.shield > 0) {
        html += `<span class="active-powerup">üõ°Ô∏è ${Math.ceil(activePowerups.shield/60)}s</span>`;
    }
    if (activePowerups.magnet > 0) {
        html += `<span class="active-powerup">üß≤ ${Math.ceil(activePowerups.magnet/60)}s</span>`;
    }
    if (activePowerups.slowmo > 0) {
        html += `<span class="active-powerup">‚è±Ô∏è ${Math.ceil(activePowerups.slowmo/60)}s</span>`;
    }
    document.getElementById('powerupBar').innerHTML = html;
}

/* ================= MOEDAS ================= */
let coins = [];
let coinTimer = 0;
let totalCoins = 0;

function createCoin() {
    if (coins.length >= MAX_COINS) return;
    
    const pattern = Math.random();
    
    if (pattern < 0.5) {
        coins.push({
            x: canvas.width + 30,
            y: groundY - 60 - Math.random() * 80,
            w: 20,
            h: 20,
            spin: 0
        });
    } else {
        const startY = groundY - 100;
        for (let i = 0; i < 5; i++) {
            coins.push({
                x: canvas.width + 30 + i * 40,
                y: startY,
                w: 20,
                h: 20,
                spin: 0
            });
        }
    }
}

function updateCoins() {
    if (!gameStarted || gamePaused) return;
    
    coinTimer++;
    if (coinTimer > 120) {
        createCoin();
        coinTimer = 0;
    }
    
    coins.forEach(c => {
        c.x -= gameSpeed;
        c.spin += 0.15;
        
        if (activePowerups.magnet > 0) {
            const dx = dino.x - c.x;
            const dy = dino.y - c.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 150) {
                c.x += dx * 0.1;
                c.y += dy * 0.1;
            }
        }
        
        if (
            dino.x < c.x + c.w &&
            dino.x + dino.w > c.x &&
            dino.y < c.y + c.h &&
            dino.y + dino.h > c.y
        ) {
            totalCoins++;
            score += 5;
            coinSound();
            createParticles(c.x + c.w/2, c.y + c.h/2, '#FFD700');
            c.collected = true;
        }
    });
    
    coins = coins.filter(c => !c.collected && c.x + c.w > 0);
}

function drawCoins() {
    coins.forEach(c => {
        const scale = Math.abs(Math.cos(c.spin));
        
        ctx.save();
        ctx.translate(c.x + c.w/2, c.y + c.h/2);
        ctx.scale(scale, 1);
        
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = '#FFA500';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = '#FFA500';
        ctx.font = 'bold 12px Arial';
        ctx.fillText('$', -4, 4);
        
        ctx.restore();
    });
}

/* ================= DINO ================= */
let faceImage = null;
let animFrame = 0;

const dino = {
    x: 80,
    y: 0,
    w: 44,
    h: 50,
    vy: 0,
    jumping: false,
    legFrame: 0,

    jump() {
        if (!this.jumping && !gameOver && gameStarted && !gamePaused) {
            this.vy = JUMP_FORCE;
            this.jumping = true;
            jumpSound();
            createParticles(this.x + this.w/2, this.y + this.h, '#9be27d');
        }
    },

    update() {
        this.vy += GRAVITY;
        this.y += this.vy;

        if (this.y >= groundY - this.h) {
            this.y = groundY - this.h;
            this.vy = 0;
            this.jumping = false;
            if (gameStarted) this.legFrame = (this.legFrame + 0.2) % 2;
        }
    },

    draw() {
        ctx.save();
        
        if (activePowerups.shield > 0) {
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.5 + Math.sin(animFrame * 0.2) * 0.3;
            ctx.beginPath();
            ctx.arc(this.x + this.w/2, this.y + this.h/2, 35, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
        
        const bodyGradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.h);
        bodyGradient.addColorStop(0, '#4a9d4e');
        bodyGradient.addColorStop(1, '#2d5f30');
        ctx.fillStyle = bodyGradient;
        
        ctx.beginPath();
        ctx.ellipse(this.x + 22, this.y + 35, 18, 20, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillRect(this.x + 18, this.y + 15, 12, 22);
        
        ctx.beginPath();
        ctx.ellipse(this.x + this.w / 2, this.y + 15, 16, 16, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#ff6b6b';
        ctx.beginPath();
        ctx.moveTo(this.x + 16, this.y + 8);
        ctx.lineTo(this.x + 20, this.y);
        ctx.lineTo(this.x + 24, this.y + 6);
        ctx.lineTo(this.x + 28, this.y + 2);
        ctx.lineTo(this.x + 32, this.y + 8);
        ctx.fill();
        
        if (faceImage) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(this.x + this.w / 2, this.y + 15, 12, 0, Math.PI * 2);
            ctx.clip();
            ctx.drawImage(faceImage, this.x + 12, this.y + 3, 24, 24);
            ctx.restore();
        } else {
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(this.x + 28, this.y + 12, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(this.x + 29, this.y + 12, 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.fillStyle = '#4a9d4e';
        ctx.fillRect(this.x + 8, this.y + 28, 6, 12);
        ctx.fillRect(this.x + 30, this.y + 28, 6, 12);
        
        const legOffset = this.jumping ? 0 : Math.floor(this.legFrame) * 4;
        ctx.fillRect(this.x + 14, this.y + 50, 8, 15);
        ctx.fillRect(this.x + 22 + legOffset, this.y + 50, 8, 15);
        
        ctx.fillStyle = '#ff8c42';
        ctx.fillRect(this.x + 12, this.y + 63, 12, 4);
        ctx.fillRect(this.x + 20 + legOffset, this.y + 63, 12, 4);
        
        ctx.restore();
    }
};

/* ================= PART√çCULAS ================= */
let particles = [];

function createParticles(x, y, color) {
    if (particles.length >= MAX_PARTICLES) return;
    
    for (let i = 0; i < 8; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 4,
            vy: Math.random() * -3 - 2,
            life: 30,
            color: color
        });
    }
}

function updateParticles() {
    particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.2;
        p.life--;
        return p.life > 0;
    });
}

function drawParticles() {
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 30;
        ctx.fillRect(p.x, p.y, 4, 4);
        ctx.globalAlpha = 1;
    });
}

/* ================= PARALLAX ================= */
let groundY = 0;
let clouds = [];
let mountains = [];

function initBackground() {
    for (let i = 0; i < 5; i++) {
        clouds.push({
            x: Math.random() * canvas.width,
            y: Math.random() * 100 + 20,
            size: 20 + Math.random() * 30,
            speed: 0.3
        });
    }
    
    for (let i = 0; i < 8; i++) {
        mountains.push({
            x: i * 200,
            height: 60 + Math.random() * 40,
            width: 150 + Math.random() * 100,
            speed: 0.5
        });
    }
    
    for (let i = 0; i < 80; i++) {
        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height * 0.7,
            size: Math.random() * 2 + 1,
            twinkle: Math.random() * Math.PI * 2
        });
    }
}

function lerpColor(color1, color2, t) {
    const c1 = hexToRgb(color1);
    const c2 = hexToRgb(color2);
    
    const r = Math.round(c1.r + (c2.r - c1.r) * t);
    const g = Math.round(c1.g + (c2.g - c1.g) * t);
    const b = Math.round(c1.b + (c2.b - c1.b) * t);
    
    return rgbToHex(r, g, b);
}

function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
}

function rgbToHex(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

function updateBackground() {
    const newTheme = getCurrentTheme(score);
    
    const lerpSpeed = 0.02;
    currentTheme.skyTop = lerpColor(currentTheme.skyTop, newTheme.skyTop, lerpSpeed);
    currentTheme.skyBottom = lerpColor(currentTheme.skyBottom, newTheme.skyBottom, lerpSpeed);
    currentTheme.groundColor = lerpColor(currentTheme.groundColor, newTheme.groundColor, lerpSpeed);
    currentTheme.cloudOpacity += (newTheme.cloudOpacity - currentTheme.cloudOpacity) * lerpSpeed;
    currentTheme.stars = newTheme.stars;
    currentTheme.moon = newTheme.moon;
    currentTheme.mountainColor = newTheme.mountainColor;
    
    document.body.style.background = currentTheme.skyTop;
    
    clouds.forEach(c => {
        c.x -= gameSpeed * c.speed;
        if (c.x + c.size < 0) {
            c.x = canvas.width;
            c.y = Math.random() * 100 + 20;
        }
    });
    
    mountains.forEach(m => {
        m.x -= gameSpeed * m.speed;
        if (m.x + m.width < 0) {
            m.x = canvas.width;
            m.height = 60 + Math.random() * 40;
        }
    });
    
    if (currentTheme.stars) {
        stars.forEach(s => {
            s.twinkle += 0.05;
            s.x -= gameSpeed * 0.1;
            if (s.x < 0) s.x = canvas.width;
        });
    }
}

function drawBackground() {
    const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    skyGradient.addColorStop(0, currentTheme.skyTop);
    skyGradient.addColorStop(0.65, currentTheme.skyBottom);
    skyGradient.addColorStop(1, currentTheme.groundColor);
    ctx.fillStyle = skyGradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    if (currentTheme.stars) {
        stars.forEach(s => {
            const opacity = (Math.sin(s.twinkle) + 1) / 2;
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    
    if (currentTheme.moon) {
        ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
        ctx.shadowBlur = 20;
        ctx.shadowColor = 'rgba(255, 255, 150, 0.5)';
        ctx.beginPath();
        ctx.arc(canvas.width - 80, 60, 30, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
    
    ctx.fillStyle = currentTheme.mountainColor;
    mountains.forEach(m => {
        ctx.beginPath();
        ctx.moveTo(m.x, groundY);
        ctx.lineTo(m.x + m.width/2, groundY - m.height);
        ctx.lineTo(m.x + m.width, groundY);
        ctx.closePath();
        ctx.fill();
    });
    
    ctx.fillStyle = `rgba(255,255,255,${currentTheme.cloudOpacity})`;
    clouds.forEach(c => {
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.size * 0.5, 0, Math.PI * 2);
        ctx.arc(c.x + c.size * 0.4, c.y, c.size * 0.6, 0, Math.PI * 2);
        ctx.arc(c.x + c.size * 0.8, c.y, c.size * 0.5, 0, Math.PI * 2);
        ctx.fill();
    });
}

/* ================= OBST√ÅCULOS ================= */
let obstacles = [];
let obstacleTimer = 0;

const obstacleTypes = [
    { w: 24, h: 35, color: '#8b4513', type: 'ground' },
    { w: 30, h: 45, color: '#654321', type: 'ground' },
    { w: 35, h: 28, color: '#a0522d', type: 'ground' },
    { w: 40, h: 25, color: '#8B4513', type: 'flying' }
];

function createObstacle() {
    const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
    
    if (type.type === 'flying') {
        obstacles.push({
            x: canvas.width + 20,
            y: groundY - 100 - Math.random() * 50,
            w: type.w,
            h: type.h,
            color: type.color,
            type: 'flying',
            wingFrame: 0,
            scored: false
        });
    } else {
        obstacles.push({
            x: canvas.width + 20,
            y: groundY - type.h,
            w: type.w,
            h: type.h,
            color: type.color,
            type: 'ground',
            scored: false
        });
    }
}

function updateObstacles() {
    if (!gameStarted || gamePaused) return;
    
    obstacleTimer++;
    const spawnRate = Math.max(50, 90 - Math.floor(score / 100));
    
    if (obstacleTimer > spawnRate) {
        createObstacle();
        obstacleTimer = 0;
    }

    obstacles.forEach(o => {
        o.x -= gameSpeed;
        
        if (o.type === 'flying') {
            o.wingFrame += 0.3;
            o.y += Math.sin(o.wingFrame) * 1.5;
        }
        
        if (!o.scored && o.x + o.w < dino.x) {
            o.scored = true;
            score += 10;
            coinSound();
        }
    });
    
    obstacles = obstacles.filter(o => o.x + o.w > 0);
    
    baseGameSpeed = 5 + Math.floor(score / 100) * 0.5;
}

function drawObstacles() {
    obstacles.forEach(o => {
        ctx.fillStyle = o.color;
        
        if (o.type === 'flying') {
            ctx.save();
            ctx.translate(o.x + o.w/2, o.y + o.h/2);
            
            ctx.fillStyle = '#6d4c41';
            ctx.fillRect(-15, -8, 30, 16);
            
            ctx.beginPath();
            ctx.arc(12, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#ff9800';
            ctx.beginPath();
            ctx.moveTo(18, -3);
            ctx.lineTo(25, 0);
            ctx.lineTo(18, 3);
            ctx.fill();
            
            const wingAngle = Math.sin(o.wingFrame) * 0.5;
            ctx.fillStyle = '#8d6e63';
            ctx.save();
            ctx.rotate(wingAngle);
            ctx.fillRect(-10, -20, 20, 15);
            ctx.restore();
            ctx.save();
            ctx.rotate(-wingAngle);
            ctx.fillRect(-10, 5, 20, 15);
            ctx.restore();
            
            ctx.restore();
        } else {
            if (o.h > 40) {
                ctx.fillRect(o.x + 8, o.y, 14, o.h);
                ctx.fillRect(o.x, o.y + 10, 8, 15);
                ctx.fillRect(o.x + 22, o.y + 15, 8, 12);
                ctx.fillStyle = '#4a7c4e';
                ctx.fillRect(o.x + 10, o.y, 3, 8);
                ctx.fillRect(o.x + 17, o.y + 5, 3, 8);
            } else if (o.h > 30) {
                ctx.fillRect(o.x + 6, o.y, 12, o.h);
                ctx.fillRect(o.x, o.y + 8, 6, 12);
                ctx.fillStyle = '#4a7c4e';
                ctx.fillRect(o.x + 9, o.y, 2, 6);
            } else {
                ctx.beginPath();
                ctx.ellipse(o.x + o.w/2, o.y + o.h/2, o.w/2, o.h/2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#8b7355';
                ctx.beginPath();
                ctx.ellipse(o.x + o.w/2, o.y + o.h/3, o.w/3, o.h/4, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    });
}

/* ================= SCORE ================= */
let score = 0;
let bestScore = Number(localStorage.getItem("dinopepe_recorde")) || 0;

function drawScore() {
    document.getElementById("scoreText").innerHTML =
        `Pontos: <strong>${Math.floor(score)}</strong> | ü™ô <strong>${totalCoins}</strong> | Recorde: <strong>${bestScore}</strong>`;
}

/* ================= COLIS√ÉO ================= */
function checkCollision() {
    if (activePowerups.shield > 0) return false;
    
    for (let o of obstacles) {
        if (
            dino.x + 8 < o.x + o.w &&
            dino.x + dino.w - 8 > o.x &&
            dino.y + dino.h - 4 > o.y &&
            dino.y + 8 < o.y + o.h
        ) {
            return true;
        }
    }
    return false;
}

/* ================= GAME ================= */
let gameOver = false;

function endGame() {
    gameOver = true;
    hitSound();
    
    createParticles(dino.x + dino.w/2, dino.y + dino.h/2, '#ff4444');

    const finalScoreNum = Math.floor(score);
    if (finalScoreNum > bestScore) {
        bestScore = finalScoreNum;
        localStorage.setItem("dinopepe_recorde", bestScore);
    }

    document.getElementById("finalScore").innerHTML = 
        `Pontos: <strong>${finalScoreNum}</strong><br>` +
        `Moedas: <strong>ü™ô ${totalCoins}</strong><br>` +
        `Recorde: <strong>${bestScore}</strong>`;
    document.getElementById("gameOverScreen").style.display = "flex";
    document.getElementById("pauseBtn").style.display = "none";
}

function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    groundY = canvas.height - 30;

    if (clouds.length === 0) initBackground();
    updateBackground();
    drawBackground();

    const groundDark = lerpColor(currentTheme.groundColor, '#000000', 0.3);
    ctx.strokeStyle = groundDark;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(0, groundY);
    ctx.lineTo(canvas.width, groundY);
    ctx.stroke();
    
    ctx.fillStyle = currentTheme.groundColor;
    for (let i = 0; i < canvas.width; i += 15) {
        ctx.fillRect(i, groundY + 2, 2, 6);
        ctx.fillRect(i + 5, groundY + 1, 2, 8);
        ctx.fillRect(i + 10, groundY + 3, 2, 5);
    }

    if (!gameOver && gameStarted) {
        dino.update();
        
        if (!gamePaused) {
            updateObstacles();
            updateCoins();
            updatePowerups();
            score += 0.1;

            if (checkCollision()) endGame();
        }
    }

    updateParticles();
    drawParticles();
    drawObstacles();
    drawCoins();
    drawPowerups();
    dino.draw();
    drawScore();
    drawPowerupBar();

    animFrame++;
    requestAnimationFrame(loop);
}

/* ================= CONTROLES ================= */
document.addEventListener("keydown", e => {
    if (e.code === "Space") {
        e.preventDefault();
        dino.jump();
    }
});

canvas.addEventListener("click", () => dino.jump());
canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    dino.jump();
});

let lastOrientation = { beta: 0, gamma: 0 };
let lastJump = 0;
let orientationSupported = false;
let lastAcceleration = { x: 0, y: 0, z: 0 };

if (window.DeviceOrientationEvent) {
    window.addEventListener("deviceorientation", e => {
        if (!gameStarted || gameOver || gamePaused) return;
        
        orientationSupported = true;
        const now = Date.now();
        
        const beta = e.beta || 0;
        const gamma = e.gamma || 0;
        
        const betaDelta = lastOrientation.beta - beta;
        
        const isShake = betaDelta > 15 && now - lastJump > 400;
        
        if (isShake) {
            dino.jump();
            lastJump = now;
        }
        
        lastOrientation = { beta, gamma };
    });
}

window.addEventListener("devicemotion", e => {
    if (orientationSupported || !gameStarted || gameOver || gamePaused) return;
    if (!e.accelerationIncludingGravity) return;
    
    const acc = e.accelerationIncludingGravity;
    const now = Date.now();
    
    const isLandscape = window.innerWidth > window.innerHeight;
    
    let shakeForce = 0;
    
    if (isLandscape) {
        shakeForce = Math.abs(acc.x - lastAcceleration.x);
    } else {
        const deltaY = Math.abs(acc.y - lastAcceleration.y);
        const deltaZ = Math.abs(acc.z - lastAcceleration.z);
        shakeForce = Math.max(deltaY, deltaZ);
    }
    
    const isShake = shakeForce > 10 && now - lastJump > 400;
    
    if (isShake) {
        dino.jump();
        lastJump = now;
    }
    
    lastAcceleration = { x: acc.x, y: acc.y, z: acc.z };
});

/* ================= FOTO ================= */
const photoPreview = document.getElementById("photoPreview");
const previewImg = document.getElementById("previewImg");
const fileInput = document.getElementById("faceUpload");

fileInput.addEventListener("change", e => {
    const file = e.target.files[0];
    if (!file) return;

    gamePaused = true;

    const reader = new FileReader();
    reader.onload = ev => {
        const img = new Image();
        img.onload = () => {
            faceImage = img;
            previewImg.src = ev.target.result;
            photoPreview.style.display = "flex";
            fileInput.style.display = "none";
            
            setTimeout(() => {
                gamePaused = false;
            }, 500);
        };
        img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
});

document.getElementById("removePhoto").onclick = () => {
    faceImage = null;
    photoPreview.style.display = "none";
    fileInput.style.display = "inline-block";
    fileInput.value = "";
};

/* ================= INICIO/RESTART ================= */
document.getElementById("startBtn").onclick = () => {
    document.getElementById("tutorialScreen").style.display = "none";
    gameStarted = true;
    
    if (typeof DeviceOrientationEvent !== 'undefined' && 
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
            .then(response => {
                if (response === 'granted') {
                    orientationSupported = true;
                }
            })
            .catch(console.error);
    }
};

function resetGame() {
    gameOver = false;
    gameStarted = false;
    gamePaused = false;
    score = 0;
    totalCoins = 0;
    gameSpeed = 5;
    baseGameSpeed = 5;
    obstacles = [];
    obstacleTimer = 0;
    particles = [];
    coins = [];
    coinTimer = 0;
    powerups = [];
    powerupTimer = 0;
    activePowerups = { shield: 0, magnet: 0, slowmo: 0 };
    
    currentTheme = getCurrentTheme(0);
    
    dino.y = 0;
    dino.vy = 0;
    dino.jumping = false;
    dino.legFrame = 0;
    
    document.getElementById("gameOverScreen").style.display = "none";
    document.getElementById("pauseBtn").style.display = "none";
    
    setTimeout(() => {
        gameStarted = true;
    }, 500);
}

document.getElementById("restartBtn").onclick = resetGame;

const pauseBtn = document.getElementById("pauseBtn");

pauseBtn.onclick = () => {
    if (!gameStarted || gameOver) return;
    
    gamePaused = !gamePaused;
    pauseBtn.textContent = gamePaused ? "‚ñ∂Ô∏è" : "‚è∏Ô∏è";
};

setInterval(() => {
    if (gameStarted && !gameOver && pauseBtn.style.display === "none") {
        pauseBtn.style.display = "block";
        pauseBtn.textContent = "‚è∏Ô∏è";
    }
}, 1000);

loop();
</script>
</body>
</html>
